<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHM & Electromagnetic Induction - IB Physics</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            color: #64b5f6;
            margin-bottom: 10px;
            font-size: 2.2em;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            text-align: center;
            color: #90caf9;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .theory-section {
            background: rgba(100, 181, 246, 0.1);
            border-left: 4px solid #64b5f6;
            padding: 20px;
            margin-bottom: 30px;
            border-radius: 8px;
        }
        
        .theory-section h2 {
            color: #64b5f6;
            margin-bottom: 15px;
        }
        
        .theory-section h3 {
            color: #90caf9;
            margin-top: 15px;
            margin-bottom: 10px;
        }
        
        .equation-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            margin: 15px 0;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        
        .equation {
            color: #ffeb3b;
            font-size: 1.1em;
            text-align: center;
            margin: 8px 0;
        }
        
        .scenario-selector {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .scenario-btn {
            padding: 12px 24px;
            background: rgba(100, 181, 246, 0.2);
            border: 2px solid #64b5f6;
            border-radius: 8px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
        }
        
        .scenario-btn:hover {
            background: rgba(100, 181, 246, 0.4);
            transform: translateY(-2px);
        }
        
        .scenario-btn.active {
            background: #64b5f6;
            color: #0a0e27;
            font-weight: bold;
        }
        
        .simulation-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 968px) {
            .simulation-area {
                grid-template-columns: 1fr;
            }
        }
        
        .canvas-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid rgba(100, 181, 246, 0.3);
        }
        
        canvas {
            width: 100%;
            border-radius: 4px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
        }
        
        .control-group label {
            display: block;
            color: #90caf9;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .control-group input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: rgba(100, 181, 246, 0.3);
            border-radius: 3px;
            outline: none;
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #64b5f6;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #64b5f6;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .value-display {
            color: #ffeb3b;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }
        
        .control-btn {
            padding: 10px 20px;
            background: rgba(76, 175, 80, 0.3);
            border: 2px solid #4caf50;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
        }
        
        .control-btn:hover {
            background: rgba(76, 175, 80, 0.5);
        }
        
        .control-btn.stop {
            background: rgba(244, 67, 54, 0.3);
            border-color: #f44336;
        }
        
        .control-btn.stop:hover {
            background: rgba(244, 67, 54, 0.5);
        }
        
        .info-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .info-panel h3 {
            color: #64b5f6;
            margin-bottom: 10px;
        }
        
        .comparison-box {
            background: rgba(255, 235, 59, 0.1);
            border-left: 4px solid #ffeb3b;
            padding: 15px;
            margin: 15px 0;
            border-radius: 6px;
        }
        
        .comparison-box h4 {
            color: #ffeb3b;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Simple Harmonic Motion & Electromagnetic Induction</h1>
        <div class="subtitle">Mathematical Parallels in Physical Systems</div>
        
        <div class="theory-section">
            <h2>Faraday's Law and Lenz's Law: The Foundation</h2>
            
            <h3>Faraday's Law of Electromagnetic Induction</h3>
            <p>The induced electromotive force (emf) in a closed circuit is equal to the negative rate of change of magnetic flux through the circuit:</p>
            <div class="equation-box">
                <div class="equation">ε = -dΦ_B/dt = -d(BA cos θ)/dt</div>
            </div>
            <p>This fundamental law connects changing magnetic fields to electric phenomena, providing the basis for generators, transformers, and countless electromagnetic devices.</p>
            
            <h3>Lenz's Law: Conservation of Energy in Disguise</h3>
            <p>The negative sign in Faraday's law is not merely conventional—it embodies <strong>Lenz's Law</strong>: the induced current flows in such a direction as to <em>oppose</em> the change in magnetic flux that produced it.</p>
            
            <div class="comparison-box">
                <h4>Why the Minus Sign Matters: Energy Conservation</h4>
                <p>If the induced current reinforced the changing flux (positive sign), we would have a runaway process: changing flux → induced current → more flux change → more current → perpetual motion! The negative sign ensures that electromagnetic induction <em>resists</em> change, dissipating energy as heat rather than creating it from nothing. This is energy conservation manifested in Maxwell's equations.</p>
            </div>
            
            <h3>The Nature of EMF: Not Just Voltage</h3>
            <p>Electromotive force is fundamentally different from electrostatic potential difference. EMF represents the work done per unit charge by <em>non-conservative forces</em>—in this case, the induced electric field arising from changing magnetic flux. This induced electric field forms closed loops (unlike conservative electrostatic fields) and can drive current even in a stationary conductor.</p>
            
            <div class="equation-box">
                <div class="equation">∮ E⃗·dl⃗ = -dΦ_B/dt  (Maxwell-Faraday equation)</div>
            </div>
            
            <h3>Maxwell's Displacement Current: The Abstract Flow</h3>
            <p>In Maxwell's complete theory, changing electric fields create magnetic fields, just as changing magnetic fields create electric fields. The "displacement current" is not a flow of actual charges but represents the rate of change of electric field:</p>
            
            <div class="equation-box">
                <div class="equation">I_d = ε₀ dΦ_E/dt</div>
            </div>
            
            <p>This abstract current exists in vacuum and insulators. However, for <strong>conduction current</strong>—the actual flow of charges we measure as "current"—we need mobile charge carriers. This is why <em>metals are essential</em>: they provide free electrons that can respond to the induced electric field, converting the abstract electromagnetic phenomenon into measurable current.</p>
            
            <div class="comparison-box">
                <h4>Why Metals? The Role of Conductors</h4>
                <p>The induced electric field exists everywhere the flux changes—even in vacuum. But without free charge carriers, there's no conduction current, just displacement current. Metals provide a "sea" of mobile electrons with negligible inertia (compared to atoms) that can immediately respond to induced fields, allowing the abstract electromagnetic induction to manifest as measurable current and dissipated energy (eddy currents, resistive heating).</p>
            </div>
        </div>
        
        <div class="theory-section">
            <h2>The SHM Connection: Differential Equations as Unifying Language</h2>
            
            <h3>Simple Harmonic Oscillator</h3>
            <div class="equation-box">
                <div class="equation">m(d²x/dt²) = -kx</div>
                <div class="equation">d²x/dt² + ω₀²x = 0,  where ω₀ = √(k/m)</div>
                <div class="equation">Solution: x(t) = A cos(ω₀t + φ)</div>
            </div>
            
            <h3>Damped Harmonic Oscillator (Mechanical)</h3>
            <div class="equation-box">
                <div class="equation">m(d²x/dt²) + b(dx/dt) + kx = 0</div>
                <div class="equation">d²x/dt² + 2γ(dx/dt) + ω₀²x = 0,  where γ = b/(2m)</div>
            </div>
            
            <h3>Falling Magnet Through Conducting Tube: Electromagnetic Damping</h3>
            <p>As a magnet falls through a conducting tube (copper, aluminum), the changing flux induces currents that create an opposing magnetic field. The equation of motion becomes:</p>
            
            <div class="equation-box">
                <div class="equation">m(d²x/dt²) = mg - b_em(dx/dt)</div>
            </div>
            
            <p>where b_em is the electromagnetic damping coefficient. At terminal velocity: b_em·v_terminal = mg</p>
            
            <h3>Pendulum with Eddy Current Damping</h3>
            <p>A metal pendulum swinging through a magnetic field experiences eddy currents. For small angles θ:</p>
            
            <div class="equation-box">
                <div class="equation">I(d²θ/dt²) + b_eddy(dθ/dt) + mgL·θ = 0</div>
            </div>
            
            <p>This is mathematically identical to the damped harmonic oscillator, with electromagnetic damping replacing mechanical friction.</p>
            
            <h3>Forced Electromagnetic Oscillations</h3>
            <p>When a conductor is forced to oscillate in a magnetic field:</p>
            
            <div class="equation-box">
                <div class="equation">m(d²x/dt²) + b_em(dx/dt) + kx = F₀ cos(ωt)</div>
            </div>
            
            <p>The induced EMF: ε(t) = -Blv(t) = -Bl·dx/dt</p>
            <p>The induced current (assuming resistance R): I(t) = ε(t)/R = -(Bl/R)·dx/dt</p>
            
            <div class="comparison-box">
                <h4>Mathematical Isomorphism</h4>
                <p><strong>Key Insight:</strong> All these systems obey the same second-order linear differential equation structure. The physics differs (springs vs. magnetic forces), but the mathematics is identical. This allows us to use the same analytical tools—characteristic equations, resonance conditions, energy considerations—across completely different physical domains.</p>
                
                <p>The damping term always appears as a first derivative (velocity-dependent), whether from air resistance, viscous drag, or electromagnetic induction. This is no coincidence: dissipative forces in nature are typically proportional to velocity, ensuring energy is monotonically removed from the system.</p>
            </div>
        </div>
        
        <div class="scenario-selector">
            <button class="scenario-btn active" onclick="setScenario('falling')">Falling Magnet in Tube</button>
            <button class="scenario-btn" onclick="setScenario('forced')">Forced Oscillation</button>
            <button class="scenario-btn" onclick="setScenario('pendulum')">Eddy Current Pendulum</button>
        </div>
        
        <div class="controls" id="controls"></div>
        
        <div class="button-group">
            <button class="control-btn" onclick="startSimulation()">Start / Resume</button>
            <button class="control-btn stop" onclick="stopSimulation()">Pause</button>
            <button class="control-btn" onclick="resetSimulation()">Reset</button>
        </div>
        
        <div class="simulation-area">
            <div class="canvas-container">
                <h3 style="color: #64b5f6; margin-bottom: 10px;">Physical Simulation</h3>
                <canvas id="physicsCanvas" width="600" height="500"></canvas>
            </div>
            <div class="canvas-container">
                <h3 style="color: #64b5f6; margin-bottom: 10px;">Position vs Time</h3>
                <canvas id="positionChart"></canvas>
            </div>
        </div>
        
        <div class="simulation-area">
            <div class="canvas-container">
                <h3 style="color: #64b5f6; margin-bottom: 10px;">Induced EMF vs Time</h3>
                <canvas id="emfChart"></canvas>
            </div>
            <div class="canvas-container">
                <h3 style="color: #64b5f6; margin-bottom: 10px;">Induced Current vs Time</h3>
                <canvas id="currentChart"></canvas>
            </div>
        </div>
        
        <div class="info-panel" id="infoPanel"></div>
    </div>
    
    <script>
        // Simulation state
        let currentScenario = 'falling';
        let isRunning = false;
        let time = 0;
        let dt = 0.016; // ~60 FPS
        let animationId = null;
        
        // Physics parameters
        let params = {
            falling: {
                mass: 0.1,          // kg
                gravity: 9.81,      // m/s²
                B: 0.5,             // Magnetic field strength (T)
                tubeRadius: 0.025,  // m
                conductivity: 5.96e7, // S/m (copper)
                tubeThickness: 0.002, // m
                position: 0,
                velocity: 0,
                emfData: [],
                currentData: [],
                posData: [],
                timeData: []
            },
            forced: {
                mass: 0.05,
                k: 10,              // Spring constant (N/m)
                B: 0.8,
                length: 0.1,        // Conductor length in field (m)
                R: 2,               // Resistance (Ω)
                omega: 5,           // Driving frequency (rad/s)
                F0: 1,              // Driving force amplitude (N)
                gamma: 0.5,         // Damping coefficient
                position: 0,
                velocity: 0,
                emfData: [],
                currentData: [],
                posData: [],
                timeData: []
            },
            pendulum: {
                length: 0.5,        // m
                mass: 0.1,          // kg
                B: 1.0,             // T
                area: 0.01,         // Pendulum plate area (m²)
                R: 5,               // Resistance (Ω)
                theta: 0.5,         // Initial angle (rad)
                omega: 0,           // Angular velocity
                emfData: [],
                currentData: [],
                posData: [],
                timeData: []
            }
        };
        
        // Chart objects
        let charts = {};
        
        // Control definitions
        const controlDefs = {
            falling: [
                { name: 'mass', label: 'Magnet Mass (kg)', min: 0.01, max: 0.5, step: 0.01 },
                { name: 'B', label: 'Magnetic Field (T)', min: 0.1, max: 2, step: 0.1 },
                { name: 'conductivity', label: 'Conductivity (×10⁷ S/m)', min: 1, max: 10, step: 0.5, scale: 1e7 },
                { name: 'tubeThickness', label: 'Tube Thickness (mm)', min: 0.5, max: 5, step: 0.1, scale: 0.001 }
            ],
            forced: [
                { name: 'mass', label: 'Mass (kg)', min: 0.01, max: 0.2, step: 0.01 },
                { name: 'k', label: 'Spring Constant (N/m)', min: 1, max: 50, step: 1 },
                { name: 'B', label: 'Magnetic Field (T)', min: 0.1, max: 2, step: 0.1 },
                { name: 'omega', label: 'Drive Frequency (rad/s)', min: 1, max: 15, step: 0.5 },
                { name: 'F0', label: 'Drive Amplitude (N)', min: 0.1, max: 5, step: 0.1 },
                { name: 'gamma', label: 'Damping Coefficient', min: 0, max: 2, step: 0.1 }
            ],
            pendulum: [
                { name: 'length', label: 'Pendulum Length (m)', min: 0.2, max: 1, step: 0.05 },
                { name: 'mass', label: 'Mass (kg)', min: 0.01, max: 0.5, step: 0.01 },
                { name: 'B', label: 'Magnetic Field (T)', min: 0.1, max: 2, step: 0.1 },
                { name: 'area', label: 'Plate Area (cm²)', min: 1, max: 50, step: 1, scale: 0.0001 },
                { name: 'R', label: 'Resistance (Ω)', min: 1, max: 20, step: 1 },
                { name: 'theta', label: 'Initial Angle (rad)', min: 0.1, max: 1.4, step: 0.1 }
            ]
        };
        
        // Initialize
        function init() {
            setupControls();
            setupCharts();
            updateInfoPanel();
            drawPhysics();
        }
        
        function setupControls() {
            const controlsDiv = document.getElementById('controls');
            controlsDiv.innerHTML = '';
            
            const defs = controlDefs[currentScenario];
            defs.forEach(def => {
                const group = document.createElement('div');
                group.className = 'control-group';
                
                const scale = def.scale || 1;
                const value = params[currentScenario][def.name];
                const displayValue = value / scale;
                
                group.innerHTML = `
                    <label>${def.label}</label>
                    <input type="range" 
                           id="${def.name}" 
                           min="${def.min}" 
                           max="${def.max}" 
                           step="${def.step}" 
                           value="${displayValue}"
                           oninput="updateParam('${def.name}', this.value, ${scale})">
                    <div class="value-display" id="${def.name}-value">${displayValue.toFixed(2)}</div>
                `;
                
                controlsDiv.appendChild(group);
            });
        }
        
        function updateParam(name, value, scale = 1) {
            params[currentScenario][name] = parseFloat(value) * scale;
            document.getElementById(name + '-value').textContent = parseFloat(value).toFixed(2);
            updateInfoPanel();
        }
        
        function setupCharts() {
            const chartConfig = {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Value',
                        data: [],
                        borderColor: '#64b5f6',
                        backgroundColor: 'rgba(100, 181, 246, 0.1)',
                        borderWidth: 2,
                        tension: 0.4,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Time (s)', color: '#90caf9' },
                            ticks: { color: '#90caf9' },
                            grid: { color: 'rgba(144, 202, 249, 0.1)' }
                        },
                        y: {
                            title: { display: true, text: 'Value', color: '#90caf9' },
                            ticks: { color: '#90caf9' },
                            grid: { color: 'rgba(144, 202, 249, 0.1)' }
                        }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            };
            
            charts.position = new Chart(document.getElementById('positionChart'), {
                ...chartConfig,
                options: {
                    ...chartConfig.options,
                    scales: {
                        ...chartConfig.options.scales,
                        y: {
                            ...chartConfig.options.scales.y,
                            title: { display: true, text: 'Position (m)', color: '#90caf9' }
                        }
                    }
                }
            });
            
            charts.emf = new Chart(document.getElementById('emfChart'), {
                ...chartConfig,
                data: {
                    ...chartConfig.data,
                    datasets: [{
                        ...chartConfig.data.datasets[0],
                        borderColor: '#ffeb3b',
                        backgroundColor: 'rgba(255, 235, 59, 0.1)'
                    }]
                },
                options: {
                    ...chartConfig.options,
                    scales: {
                        ...chartConfig.options.scales,
                        y: {
                            ...chartConfig.options.scales.y,
                            title: { display: true, text: 'EMF (V)', color: '#90caf9' }
                        }
                    }
                }
            });
            
            charts.current = new Chart(document.getElementById('currentChart'), {
                ...chartConfig,
                data: {
                    ...chartConfig.data,
                    datasets: [{
                        ...chartConfig.data.datasets[0],
                        borderColor: '#4caf50',
                        backgroundColor: 'rgba(76, 175, 80, 0.1)'
                    }]
                },
                options: {
                    ...chartConfig.options,
                    scales: {
                        ...chartConfig.options.scales,
                        y: {
                            ...chartConfig.options.scales.y,
                            title: { display: true, text: 'Current (A)', color: '#90caf9' }
                        }
                    }
                }
            });
        }
        
        function updateCharts() {
            const p = params[currentScenario];
            const maxPoints = 500;
            
            if (p.timeData.length > maxPoints) {
                p.timeData = p.timeData.slice(-maxPoints);
                p.posData = p.posData.slice(-maxPoints);
                p.emfData = p.emfData.slice(-maxPoints);
                p.currentData = p.currentData.slice(-maxPoints);
            }
            
            const timePoints = p.timeData.map(t => ({ x: t, y: 0 }));
            
            charts.position.data.datasets[0].data = p.timeData.map((t, i) => ({ x: t, y: p.posData[i] }));
            charts.emf.data.datasets[0].data = p.timeData.map((t, i) => ({ x: t, y: p.emfData[i] }));
            charts.current.data.datasets[0].data = p.timeData.map((t, i) => ({ x: t, y: p.currentData[i] }));
            
            charts.position.update();
            charts.emf.update();
            charts.current.update();
        }
        
        function drawPhysics() {
            const canvas = document.getElementById('physicsCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            
            ctx.clearRect(0, 0, w, h);
            
            if (currentScenario === 'falling') {
                drawFallingMagnet(ctx, w, h);
            } else if (currentScenario === 'forced') {
                drawForcedOscillator(ctx, w, h);
            } else if (currentScenario === 'pendulum') {
                drawPendulum(ctx, w, h);
            }
        }
        
        function drawFallingMagnet(ctx, w, h) {
            const p = params.falling;
            
            // Draw tube
            const tubeX = w / 2;
            const tubeTop = 50;
            const tubeHeight = h - 100;
            const tubeWidth = 60;
            
            ctx.strokeStyle = '#b8860b';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(tubeX - tubeWidth/2, tubeTop);
            ctx.lineTo(tubeX - tubeWidth/2, tubeTop + tubeHeight);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(tubeX + tubeWidth/2, tubeTop);
            ctx.lineTo(tubeX + tubeWidth/2, tubeTop + tubeHeight);
            ctx.stroke();
            
            // Draw magnet
            const maxDrop = tubeHeight - 60;
            const magnetY = tubeTop + Math.min(p.position * 100, maxDrop);
            
            // North pole (red)
            ctx.fillStyle = '#f44336';
            ctx.fillRect(tubeX - 20, magnetY, 40, 20);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('N', tubeX, magnetY + 15);
            
            // South pole (blue)
            ctx.fillStyle = '#2196f3';
            ctx.fillRect(tubeX - 20, magnetY + 20, 40, 20);
            ctx.fillStyle = '#fff';
            ctx.fillText('S', tubeX, magnetY + 35);
            
            // Draw field lines
            ctx.strokeStyle = 'rgba(100, 181, 246, 0.3)';
            ctx.lineWidth = 1;
            for (let i = -3; i <= 3; i++) {
                ctx.beginPath();
                ctx.arc(tubeX, magnetY + 20, Math.abs(i) * 15 + 30, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Draw induced current indicators
            if (Math.abs(p.velocity) > 0.01) {
                const currentDirection = p.velocity > 0 ? 1 : -1;
                ctx.strokeStyle = '#4caf50';
                ctx.lineWidth = 2;
                
                // Left side current
                for (let y = tubeTop + 30; y < tubeTop + tubeHeight - 30; y += 40) {
                    drawArrow(ctx, tubeX - tubeWidth/2 - 20, y, tubeX - tubeWidth/2 - 20, y + 20 * currentDirection);
                }
                
                // Right side current (opposite direction)
                for (let y = tubeTop + 30; y < tubeTop + tubeHeight - 30; y += 40) {
                    drawArrow(ctx, tubeX + tubeWidth/2 + 20, y, tubeX + tubeWidth/2 + 20, y - 20 * currentDirection);
                }
            }
            
            // Info text
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`v = ${p.velocity.toFixed(3)} m/s`, 20, 30);
            ctx.fillText(`y = ${p.position.toFixed(3)} m`, 20, 50);
        }
        
        function drawForcedOscillator(ctx, w, h) {
            const p = params.forced;
            
            const centerY = h / 2;
            const equilibrium = w / 2;
            const scale = 100; // pixels per meter
            const massX = equilibrium + p.position * scale;
            
            // Draw wall
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(50, centerY - 100);
            ctx.lineTo(50, centerY + 100);
            ctx.stroke();
            
            // Draw spring
            ctx.strokeStyle = '#90caf9';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, centerY);
            
            const springCoils = 12;
            const springWidth = 20;
            const springLength = massX - 50 - 30;
            
            for (let i = 0; i <= springCoils; i++) {
                const x = 50 + (i / springCoils) * springLength;
                const y = centerY + (i % 2 === 0 ? springWidth : -springWidth);
                ctx.lineTo(x, y);
            }
            ctx.lineTo(massX - 30, centerY);
            ctx.stroke();
            
            // Draw mass
            ctx.fillStyle = '#64b5f6';
            ctx.fillRect(massX - 30, centerY - 25, 60, 50);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(massX - 30, centerY - 25, 60, 50);
            
            // Draw magnetic field region
            ctx.fillStyle = 'rgba(255, 235, 59, 0.1)';
            ctx.fillRect(equilibrium - 150, centerY - 80, 300, 160);
            ctx.strokeStyle = '#ffeb3b';
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(equilibrium - 150, centerY - 80, 300, 160);
            ctx.setLineDash([]);
            
            ctx.fillStyle = '#ffeb3b';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('B field region', equilibrium, centerY - 90);
            
            // Draw field lines
            ctx.strokeStyle = 'rgba(255, 235, 59, 0.3)';
            ctx.lineWidth = 1;
            for (let y = centerY - 60; y <= centerY + 60; y += 20) {
                ctx.beginPath();
                ctx.moveTo(equilibrium - 140, y);
                ctx.lineTo(equilibrium + 140, y);
                ctx.stroke();
                
                // Field dots
                for (let x = equilibrium - 130; x <= equilibrium + 130; x += 20) {
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw driving force arrow
            const forceScale = 50;
            const forceArrowLength = Math.cos(p.omega * time) * forceScale;
            if (Math.abs(forceArrowLength) > 5) {
                ctx.strokeStyle = '#f44336';
                ctx.lineWidth = 3;
                drawArrow(ctx, massX + 40, centerY, massX + 40 + forceArrowLength, centerY);
                ctx.fillStyle = '#f44336';
                ctx.font = '12px Arial';
                ctx.fillText('F(t)', massX + 40 + forceArrowLength + 15, centerY - 10);
            }
            
            // Info text
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`x = ${p.position.toFixed(3)} m`, 20, 30);
            ctx.fillText(`v = ${p.velocity.toFixed(3)} m/s`, 20, 50);
            ctx.fillText(`ω/ω₀ = ${(p.omega / Math.sqrt(p.k / p.mass)).toFixed(2)}`, 20, 70);
        }
        
        function drawPendulum(ctx, w, h) {
            const p = params.pendulum;
            
            const pivotX = w / 2;
            const pivotY = 80;
            const scale = 300; // pixels per meter
            const L = p.length * scale;
            
            const bobX = pivotX + L * Math.sin(p.theta);
            const bobY = pivotY + L * Math.cos(p.theta);
            
            // Draw pivot
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.arc(pivotX, pivotY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw rod
            ctx.strokeStyle = '#90caf9';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(pivotX, pivotY);
            ctx.lineTo(bobX, bobY);
            ctx.stroke();
            
            // Draw bob (metal plate)
            ctx.fillStyle = '#b0bec5';
            ctx.fillRect(bobX - 30, bobY - 20, 60, 40);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(bobX - 30, bobY - 20, 60, 40);
            
            // Draw magnetic field region
            const fieldWidth = 200;
            const fieldHeight = 300;
            const fieldX = pivotX - fieldWidth / 2;
            const fieldY = pivotY + 50;
            
            ctx.fillStyle = 'rgba(255, 0, 150, 0.1)';
            ctx.fillRect(fieldX, fieldY, fieldWidth, fieldHeight);
            ctx.strokeStyle = '#ff0096';
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(fieldX, fieldY, fieldWidth, fieldHeight);
            ctx.setLineDash([]);
            
            // Draw field vectors (into page)
            ctx.fillStyle = '#ff0096';
            for (let x = fieldX + 30; x < fieldX + fieldWidth - 30; x += 40) {
                for (let y = fieldY + 30; y < fieldY + fieldHeight - 30; y += 40) {
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#ff0096';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x - 6, y - 6);
                    ctx.lineTo(x + 6, y + 6);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x - 6, y + 6);
                    ctx.lineTo(x + 6, y - 6);
                    ctx.stroke();
                }
            }
            
            ctx.fillStyle = '#ff0096';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('⊗ B field (into page)', pivotX, fieldY - 10);
            
            // Draw eddy current visualization if moving
            if (Math.abs(p.omega) > 0.01 && bobY > fieldY && bobY < fieldY + fieldHeight) {
                ctx.strokeStyle = 'rgba(76, 175, 80, 0.6)';
                ctx.lineWidth = 2;
                
                // Circular eddy currents in the plate
                const eddyRadius = 15;
                ctx.beginPath();
                ctx.arc(bobX, bobY, eddyRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Arrow showing current direction
                const arrowAngle = p.omega > 0 ? Math.PI / 4 : -Math.PI / 4;
                drawArrow(ctx, 
                    bobX + eddyRadius * Math.cos(arrowAngle), 
                    bobY + eddyRadius * Math.sin(arrowAngle),
                    bobX + eddyRadius * Math.cos(arrowAngle + 0.5), 
                    bobY + eddyRadius * Math.sin(arrowAngle + 0.5)
                );
            }
            
            // Draw equilibrium line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(pivotX, pivotY);
            ctx.lineTo(pivotX, pivotY + L + 50);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Info text
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`θ = ${(p.theta * 180 / Math.PI).toFixed(1)}°`, 20, 30);
            ctx.fillText(`ω = ${p.omega.toFixed(3)} rad/s`, 20, 50);
        }
        
        function drawArrow(ctx, x1, y1, x2, y2) {
            const headlen = 8;
            const angle = Math.atan2(y2 - y1, x2 - x1);
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }
        
        function updatePhysics() {
            if (currentScenario === 'falling') {
                updateFalling();
            } else if (currentScenario === 'forced') {
                updateForced();
            } else if (currentScenario === 'pendulum') {
                updatePendulum();
            }
            
            time += dt;
        }
        
        function updateFalling() {
            const p = params.falling;
            
            // Electromagnetic damping coefficient
            // b_em ≈ (B² * l² * σ * A * t) where l is circumference, A is area, t is thickness
            const circumference = 2 * Math.PI * p.tubeRadius;
            const area = circumference * p.tubeRadius; // Approximate induced area
            const b_em = (p.B * p.B * p.conductivity * area * p.tubeThickness) / 2;
            
            // F = mg - b_em * v
            const acceleration = p.gravity - (b_em / p.mass) * p.velocity;
            
            p.velocity += acceleration * dt;
            p.position += p.velocity * dt;
            
            // Calculate induced EMF and current
            // ε = -dΦ/dt ≈ -B * A * dv/dt (simplified for visualization)
            const emf = -p.B * area * acceleration;
            const current = -b_em * p.velocity / (p.B * circumference); // Approximate
            
            p.emfData.push(emf);
            p.currentData.push(current);
            p.posData.push(p.position);
            p.timeData.push(time);
        }
        
        function updateForced() {
            const p = params.forced;
            
            const omega0 = Math.sqrt(p.k / p.mass);
            
            // Electromagnetic damping when in field
            const b_em = (p.B * p.B * p.length * p.length) / p.R;
            const totalGamma = p.gamma + b_em / (2 * p.mass);
            
            // Driving force
            const F_drive = p.F0 * Math.cos(p.omega * time);
            
            // a = (F_drive - 2*m*γ*v - k*x) / m
            const acceleration = (F_drive - 2 * p.mass * totalGamma * p.velocity - p.k * p.position) / p.mass;
            
            p.velocity += acceleration * dt;
            p.position += p.velocity * dt;
            
            // EMF and current
            const emf = -p.B * p.length * p.velocity;
            const current = emf / p.R;
            
            p.emfData.push(emf);
            p.currentData.push(current);
            p.posData.push(p.position);
            p.timeData.push(time);
        }
        
        function updatePendulum() {
            const p = params.pendulum;
            
            const g = 9.81;
            const I = p.mass * p.length * p.length; // Moment of inertia
            
            // Eddy current damping torque ∝ ω
            const b_eddy = (p.B * p.B * p.area * p.area) / (p.R * p.length);
            
            // α = -(g/L)*sin(θ) - (b_eddy/I)*ω
            const alpha = -(g / p.length) * Math.sin(p.theta) - (b_eddy / I) * p.omega;
            
            p.omega += alpha * dt;
            p.theta += p.omega * dt;
            
            // EMF from changing flux as pendulum swings
            const v_tangent = p.omega * p.length;
            const emf = -p.B * p.area * p.omega; // Simplified
            const current = emf / p.R;
            
            p.emfData.push(emf);
            p.currentData.push(current);
            p.posData.push(p.theta);
            p.timeData.push(time);
        }
        
        function updateInfoPanel() {
            const panel = document.getElementById('infoPanel');
            
            if (currentScenario === 'falling') {
                const p = params.falling;
                const b_em = (p.B * p.B * p.conductivity * 2 * Math.PI * p.tubeRadius * p.tubeRadius * p.tubeThickness) / 2;
                const v_terminal = (p.mass * p.gravity) / b_em;
                
                panel.innerHTML = `
                    <h3>Falling Magnet Analysis</h3>
                    <p><strong>Electromagnetic damping coefficient:</strong> b<sub>em</sub> = ${b_em.toFixed(4)} kg/s</p>
                    <p><strong>Terminal velocity:</strong> v<sub>t</sub> = mg/b<sub>em</sub> = ${v_terminal.toFixed(3)} m/s</p>
                    <p><strong>Physical mechanism:</strong> As magnet falls, changing flux induces eddy currents in tube walls. 
                    These currents create a magnetic field opposing the motion (Lenz's law), resulting in an upward force 
                    proportional to velocity. At terminal velocity, this electromagnetic force balances gravity.</p>
                `;
            } else if (currentScenario === 'forced') {
                const p = params.forced;
                const omega0 = Math.sqrt(p.k / p.mass);
                const b_em = (p.B * p.B * p.length * p.length) / p.R;
                const totalGamma = p.gamma + b_em / (2 * p.mass);
                const Q = omega0 / (2 * totalGamma);
                
                panel.innerHTML = `
                    <h3>Forced Oscillation Analysis</h3>
                    <p><strong>Natural frequency:</strong> ω₀ = ${omega0.toFixed(3)} rad/s</p>
                    <p><strong>Driving frequency:</strong> ω = ${p.omega.toFixed(3)} rad/s</p>
                    <p><strong>Frequency ratio:</strong> ω/ω₀ = ${(p.omega/omega0).toFixed(3)}</p>
                    <p><strong>EM damping coefficient:</strong> b<sub>em</sub> = B²l²/R = ${b_em.toFixed(4)} kg/s</p>
                    <p><strong>Quality factor:</strong> Q = ${Q.toFixed(2)}</p>
                    <p><strong>Resonance condition:</strong> Maximum amplitude occurs when ω ≈ ω₀ for low damping</p>
                `;
            } else if (currentScenario === 'pendulum') {
                const p = params.pendulum;
                const omega0 = Math.sqrt(9.81 / p.length);
                const b_eddy = (p.B * p.B * p.area * p.area) / (p.R * p.length);
                const I = p.mass * p.length * p.length;
                const tau_decay = I / b_eddy;
                
                panel.innerHTML = `
                    <h3>Eddy Current Pendulum Analysis</h3>
                    <p><strong>Natural frequency (small angle):</strong> ω₀ = ${omega0.toFixed(3)} rad/s</p>
                    <p><strong>Period:</strong> T = ${(2 * Math.PI / omega0).toFixed(3)} s</p>
                    <p><strong>Eddy damping coefficient:</strong> b<sub>eddy</sub> = ${b_eddy.toFixed(6)} N·m·s</p>
                    <p><strong>Decay time constant:</strong> τ = I/b<sub>eddy</sub> = ${tau_decay.toFixed(2)} s</p>
                    <p><strong>Physical mechanism:</strong> Metal plate moving through magnetic field experiences induced 
                    eddy currents. These circulating currents dissipate energy as I²R heating, causing exponential decay 
                    of amplitude. No mechanical friction needed—purely electromagnetic damping!</p>
                `;
            }
        }
        
        function animate() {
            if (isRunning) {
                updatePhysics();
                drawPhysics();
                updateCharts();
                animationId = requestAnimationFrame(animate);
            }
        }
        
        function startSimulation() {
            isRunning = true;
            animate();
        }
        
        function stopSimulation() {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        function resetSimulation() {
            stopSimulation();
            time = 0;
            
            const p = params[currentScenario];
            if (currentScenario === 'falling') {
                p.position = 0;
                p.velocity = 0;
            } else if (currentScenario === 'forced') {
                p.position = 0;
                p.velocity = 0;
            } else if (currentScenario === 'pendulum') {
                p.theta = parseFloat(document.getElementById('theta').value);
                p.omega = 0;
            }
            
            p.emfData = [];
            p.currentData = [];
            p.posData = [];
            p.timeData = [];
            
            updateCharts();
            drawPhysics();
        }
        
        function setScenario(scenario) {
            stopSimulation();
            currentScenario = scenario;
            
            // Update button states
            document.querySelectorAll('.scenario-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            resetSimulation();
            setupControls();
            updateInfoPanel();
        }
        
        // Initialize on load
        window.onload = init;
    </script>
</body>
</html>